import { RedisClient } from "../../infrastructure/database/redisClient";
import { ChapterDB } from "../../models/chapter";

export class ChaptersRepository {
  private chaptersDB: ReturnType<RedisClient["getChaptersStore"]>;

  constructor(redisChapters = RedisClient.getInstance().getChaptersStore()) {
    this.chaptersDB = redisChapters;
  }

  /**
   * Fetch a single chapter .
   * Either:
   *    - fetch it from the redis.
   *    - It's currently being generated by another and a lock is in the redis for it, we wait for the lock to be removed to fetch it from the redis
   *    - It does not exist and is not being generated yet, we launch the generation using openAI API and put a lock in redis.
   */
  public async getChapter(
    bookID: string,
    chapterNumber: number,
    allowBiggerLimit: boolean,
  ): Promise<ChapterDB | null> {
    const cached = await this.chaptersDB.getChapter(bookID, chapterNumber);
    if (cached) {
      return cached;
    }

    const lockCreated = await this.chaptersDB.createChapterLock(
      bookID,
      chapterNumber,
    );
    if (!lockCreated) {
      // that mean a lock already exist in redis, so we wait for the chapter to be available
      return await this.waitForChapter(bookID, chapterNumber);
    }

    try {
      const generated = await this.generateChapter(
        bookID,
        chapterNumber,
        allowBiggerLimit,
      );
      await this.chaptersDB.saveChapter(bookID, chapterNumber, generated);
      return generated;
    } finally {
      await this.chaptersDB.deleteChapterLock(bookID, chapterNumber);
    }
  }

  /**
   * This function is called when we know the chapter is being generated in the background and will be added into redis soon.
   * We wait for it to be available and return it.
   * If after
   */
  private async waitForChapter(
    bookID: string,
    chapterNumber: number,
    timeoutMs = 300000, // 5 min
  ): Promise<ChapterDB | null> {
    const start = Date.now();
    while (Date.now() - start < timeoutMs) {
      const data = await this.chaptersDB.getChapter(bookID, chapterNumber);
      if (data) {
        return data;
      }

      if (!(await this.chaptersDB.lockExists(bookID, chapterNumber))) {
        return null;
      }

      // wait 15sec before retrying
      await new Promise((r) => setTimeout(r, 15000));
    }
    return null;
  }

  private async generateChapter(
    bookID: string,
    chapterNumber: number,
    allowBiggerLimit: boolean,
  ): Promise<ChapterDB> {
    // const instanceSourceWebsite = new sourceWebsiteManager();
    // const orchestrator = new generativeTextOrchestrator(instanceSourceWebsite);
    // const dataChapter = await orchestrator.computeChapter(
    //   destination,
    //   allowBiggerLimit,
    // );
    //
    // // if there is an error
    // if (!dataChapter.success) {
    //   return res.render("error", {
    //     title: "Error",
    //     errorAI: dataChapter.message,
    //     detail: dataChapter.detail,
    //   });
    // }
    //
    // // everything is good
    // return res.render("chapter", dataChapter.data);
    return {
      id: `MOCK_BOOK_${bookID}`,
      title: `MOCK_TITLE -  id: ${bookID} - chapterNumber: ${chapterNumber} - allowBiggerLimit: ${allowBiggerLimit}`,
      body: "MOCK_BODY",
    };
  }

  /**
   * Delete a chapter
   */
  public async delete(bookID: string, chapterNumber: number): Promise<void> {
    await this.chaptersDB.deleteChapter(bookID, chapterNumber);
  }
}
