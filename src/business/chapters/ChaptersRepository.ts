import { RedisClient } from "../../infrastructure/database/redisClient";
import { ChapterDB } from "../../models/chapter";
import { generativeTextOrchestrator } from "../textProcessing/generativeTextOrchestrator";
import { sourceWebsiteManager } from "../sourcesWebsites/sourceWebsiteManager";
import crypto from "node:crypto";
import { HydratedBookmark } from "../../models/bookmark";
import { ReaderDataConfig } from "../../models/readerConfig";
import { UsersRepository } from "../users/UsersRepository";

export class ChaptersRepository {
  private chaptersDB: ReturnType<RedisClient["getChaptersStore"]>;

  constructor(redisChapters = RedisClient.getInstance().getChaptersStore()) {
    this.chaptersDB = redisChapters;
  }

  /**
   * Fetch a single chapter . chapterNumber requested is not necessarly the one from the bookmark.
   * Either:
   *    - fetch it from the redis.
   *    - It's currently being generated by another and a lock is in the redis for it, we wait for the lock to be removed to fetch it from the redis
   *    - It does not exist and is not being generated yet, we launch the generation using openAI API and put a lock in redis.
   */
  public async getChapter(
    hydratedBookmark: HydratedBookmark,
    chapterNumber: number,
    allowBiggerLimit: boolean,
  ): Promise<ChapterDB | null> {
    const bookID = hydratedBookmark.bookmark.bookID;
    const cached = await this.chaptersDB.getChapter(bookID, chapterNumber);
    if (cached) {
      return cached;
    }

    const lockCreated = await this.chaptersDB.createChapterLock(
      bookID,
      chapterNumber,
    );
    if (!lockCreated) {
      // that mean a lock already exist in redis, so we wait for the chapter to be available
      return await this.waitForChapter(bookID, chapterNumber);
    }

    try {
      const generated = await this.generateChapter(
        hydratedBookmark,
        chapterNumber,
        allowBiggerLimit,
      );
      if (generated) {
        await this.chaptersDB.saveChapter(bookID, chapterNumber, generated);
      }
      return generated;
    } finally {
      await this.chaptersDB.deleteChapterLock(bookID, chapterNumber);
    }
  }

  /**
   * This function is called when we know the chapter is being generated in the background and will be added into redis soon.
   * We wait for it to be available and return it.
   * If after
   */
  private async waitForChapter(
    bookID: string,
    chapterNumber: number,
    timeoutMs = 300000, // 5 min
  ): Promise<ChapterDB | null> {
    const start = Date.now();
    while (Date.now() - start < timeoutMs) {
      const data = await this.chaptersDB.getChapter(bookID, chapterNumber);
      if (data) {
        return data;
      }

      if (!(await this.chaptersDB.lockExists(bookID, chapterNumber))) {
        return null;
      }

      // wait 15sec before retrying
      await new Promise((r) => setTimeout(r, 15000));
    }
    return null;
  }

  private chooseReaderConfig(
    hydratedBookmark: HydratedBookmark,
    chapterNumber: number,
  ): ReaderDataConfig {
    let result: ReaderDataConfig;
    const currentSourceSiteCode =
      hydratedBookmark.bookmark.currentSourceSiteCode;

    const canUseCurrentCodeOverwriteReader: boolean =
      Array.isArray(hydratedBookmark.bookmark.readerDataOverride) &&
      hydratedBookmark.bookmark.readerDataOverride.some(
        (el) => el.sourceSiteCode === currentSourceSiteCode,
      );
    const canUseCurrentCodeDefaultReader: boolean =
      Array.isArray(hydratedBookmark.book.readerDataConfigs) &&
      hydratedBookmark.book.readerDataConfigs.some(
        (el) => el.sourceSiteCode === currentSourceSiteCode,
      );

    if (canUseCurrentCodeOverwriteReader) {
      // can use the overwrite config for the selected sourceSiteCode
      result = hydratedBookmark.bookmark.readerDataOverride!.find(
        (el) => el.sourceSiteCode === currentSourceSiteCode,
      )!;
    } else if (canUseCurrentCodeDefaultReader) {
      // can't use the overwrite config for the selected sourceSiteCode, but can use the default one for the selected sourceSiteCode
      result = hydratedBookmark.book.readerDataConfigs.find(
        (el) => el.sourceSiteCode === currentSourceSiteCode,
      )!;
    } else {
      // can't find a corresponding config, use the default one
      result = hydratedBookmark.book.readerDataConfigs[0];
    }

    // force the chapter to the wanted value in the reader
    result.values["CHAPTER_NUMBER"] = chapterNumber;

    return result;
  }

  private async generateChapter(
    hydratedBookmark: HydratedBookmark,
    chapterNumber: number,
    allowBiggerLimit: boolean,
  ): Promise<ChapterDB | null> {
    // fetch the user to check it's right
    const instanceUsersRepository = new UsersRepository();
    const user = await instanceUsersRepository.fetchByID(
      hydratedBookmark.bookmark.userID,
    );
    if (!user || !user.roles.includes("ADMINISTRATOR")) {
      console.error("User can't make OPENAI API CAll");
      return null;
    }
    const instanceSourceWebsite = new sourceWebsiteManager(
      this.chooseReaderConfig(hydratedBookmark, chapterNumber),
    );
    const orchestrator = new generativeTextOrchestrator(instanceSourceWebsite);
    const dataChapter = await orchestrator.computeChapter(
      hydratedBookmark,
      chapterNumber,
      allowBiggerLimit,
    );

    // if there is an error
    if (!dataChapter.success) {
      console.error(dataChapter.message);
      if (dataChapter.detail) {
        console.error(JSON.stringify(dataChapter.detail));
      }
      return null;
    }

    // everything is good
    return {
      id: crypto.randomUUID(),
      title: dataChapter.data.title,
      body: dataChapter.data.chapter,
    };
  }

  /**
   * Delete a chapter
   */
  public async delete(bookID: string, chapterNumber: number): Promise<void> {
    await this.chaptersDB.deleteChapter(bookID, chapterNumber);
  }
}
